<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Operating Systems Weekly Reports</title>
  <style>
    body {
      font-family: "Segoe UI", Arial, sans-serif;
      background-color: #0d1117;
      color: #e6edf3;
      margin: 0;
      padding: 0;
      line-height: 1.6;
    }

    header {
      background-color: #161b22;
      padding: 1.5rem;
      text-align: center;
      border-bottom: 2px solid #30363d;
    }

    header h1 {
      margin: 0;
      color: #58a6ff;
      font-size: 2.5rem;
    }
    
    main {
      max-width: 800px;
      margin: 2rem auto;
      /*padding: 0 1rem;*/
    }

    section {
      background-color: #1c2128;
      border: 1px solid #30363d;
      border-radius: 10px;
      padding: 1rem 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
      width: 100%;       
      height: auto;         
      display: inline-block;
    }

    section h2 {
      color: #58a6ff;
    }

    section h4 { 
      margin: 0;
      color: #ffffff;
      border-bottom: 1px solid #30363d;
      padding-bottom: 0.3rem;
      font-size: 1.0rem;
      text-align: right;
    }
    
    footer {
      text-align: center;
      padding: 1rem;
      font-size: 0.9rem;
      color: #8b949e;
      border-top: 1px solid #30363d;
    }

    a {
      color: #58a6ff;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
      background-color: #1c2128;
      border: 1px solid #30363d;
      border-radius: 10px;
      overflow: hidden;
      height: auto;         
      display: inline-block;
    }
    
    th, td {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #30363d;
      text-align: left;
      vertical-align: top;
    }
    
    th {
      background-color: #161b22;
      color: #58a6ff;
    }
    
    tr:last-child td {
      border-bottom: none;
    }
    
    pre {
      background-color: #000000;
      padding: 1rem;
      border-radius: 8px;
      border: 1px solid #30363d;
      overflow-x: auto;       
      white-space: pre-wrap; 
      word-wrap: break-word;
      margin: 1rem 0;
    }
    
    code {
      font-family: "Fira Code", "Courier New", monospace;
      background-color: #000000;
      color: #e6edf3;
      border-radius: 4px;
      border: 1px solid #30363d;
      font-size: 1rem;
    }
    
    .fixed-img {
      width: 100%;       
      height: auto;         
      display: inline-block;
    }
  </style>
</head>
<body>
  <header>
    <h1>Operating Systems Weekly Reports</h1>
    <p>By Jack Turner</p>
  </header>

  <main>
    <section>
      <h2>Week 1: System Planning and Distribution Selection</h2>
      <h4>24/10/2025</h4>
      <h3>System Architecture Diagram</h3>
      <img src="OSArchitectureDiagram.png" alt="Systems Architecture Diagram" align="middle" class="fixed-img">
      <h3>Distribution Selection Justification</h3>
      <table>
        <thead>
          <tr>
            <th>Distribution</th>
            <th>Pros</th>
            <th>Cons</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Ubuntu Server</strong></td>
            <td>Widely supported, stable LTS, large community, compatible with VirtualBox</td>
            <td>Slightly heavier base install</td>
          </tr>
          <tr>
            <td><strong>Debian</strong></td>
            <td>Extremely stable, secure, minimal setup</td>
            <td>Older packages, smaller repositories for new tools</td>
          </tr>
          <tr>
            <td><strong>CentOS</strong></td>
            <td>Enterprise-level stability, SELinux enabled by default</td>
            <td>Steeper learning curve, enterprise-focused tools</td>
          </tr>
        </tbody>
      </table>
      <p>After comparing several Linux server distributions, I decided to use <strong>Ubuntu Server</strong> for my project. 
      I chose Ubuntu because it is stable, easy to configure, and well-documented, which makes it suitable for developing my command-line and remote administration skills. 
      Although <strong>Debian</strong> is extremely reliable and secure, its slower updates and smaller repositories make it less flexible for experimenting. 
      On the other hand, <strong>CentOS</strong> is designed more for enterprise environments and has a steeper learning curve. 
      Overall, Ubuntu provides the best balance between usability, support, and performance for a headless SSH-based setup.</p>
      <h3>Workstation Configuration Decision</h3>
      <p>The workstation used is my host operating system running on macOS. MacOS provides built in terminal SSH access to the server virtual machine; 
      this method ensures that all administration is performed remotely, and aligning with professional practices. VirtualBox is used to host the server image and isolating it from the host environment.</p>
      <h3>Network Configuration Documentation</h3>
      <p>Due to university network restrictions preventing LAN connections over Wi-Fi, I configured my virtual machine 
      to use a <strong>NAT network</strong> in <strong>VirtualBox 7.2.4</strong> instead of a host-only adapter. 
      To enable secure remote administration, I created a <strong>port forwarding rule</strong> that maps 
      SSH traffic from the host (MacBook) to the guest virtual machine. This forwards connections from 
      <code>127.0.0.1:2222</code> on the host to port <code>22</code> on the virtual machine, allowing me to 
      connect locally using the command <code>ssh -p 2222 admin@127.0.0.1</code>. This approach avoids 
      university network restrictions while maintaining a realistic remote management workflow.</p>
      <h3>System Specifications</h3>
      <p>I used the <code>uname, free, df -h, ip addr, lsb_release</code> commands to provide the following specifications.</p>
      <pre><code style="border: 0px">
      # uname -a
      Linux
      
      # free -h
                    total        used        free      shared  buff/cache   available
      Mem:         2001372      246300     1165364        1024      678632     1755072
      Swap:              0           0           0
      
      # df -h
      Filesystem      Size  Used Avail Use% Mounted on
      tmpfs           196M  1.2M  195M   1% /run
      /dev/sda2        24G  2.7G   20G  12% /
      tmpfs           981M     0  981M   0% /dev/shm
      /dev/sda1       1.1G  6.4M  1.0G   1% /boot/efi
      tmpfs           196M  4.0K  196M   1% /run/user/1000
      
      # ip addr
      1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
          inet 127.0.0.1/8 scope host lo
      2: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000
          inet 10.0.2.15/24 scope global dynamic enp0s8
      
      # lsb_release -a
      Distributor ID: Ubuntu
      Description:    Ubuntu 22.04 LTS
      </code></pre>
    </section>
    <section>
      <h2>Week 2: Security Planning and Testing Methodology</h2>
      <h4>31/10/2025</h4>
      <h3>Performance Testing Plane</h3>
      <p>For this phase, I plan to design a performance testing and monitoring approach that ensures my Linux server 
      remains stable and secure during remote administration. I will monitor resource usage using command-line tools such as 
      <code>top</code>, <code>free</code>, and <code>df -h</code> to assess CPU load, memory utilisation, and disk activity. 
      Network responsiveness will be tested using <code>ping</code> and <code>traceroute</code>, while service reliability will 
      be checked through <code>systemctl status ssh</code> and log analysis with <code>journalctl</code>. These results will form 
      the foundation for comparing performance before and after security hardening, helping to identify any negative impact caused
      by configuration changes. By maintaining a clear testing methodology and consistent monitoring approach, I aim to ensure 
      the system remains efficient, responsive, and secure throughout the deployment.</p>
      <h3>Security Configuration Checklist</h3>
      <table>
        <thead>
          <tr>
            <th>Area</th>
            <th>Action</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>SSH Hardening</strong></td>
            <td>Disabled root login, limited login attempts</td>
            <td>Prevent brute-force and root access</td>
          </tr>
          <tr>
            <td><strong>Firewall Configuration</strong></td>
            <td>Installed & configured UFW</td>
            <td>Restrict inbound traffic</td>
          </tr>
          <tr>
            <td><strong>Mandatory Access Control</strong></td>
            <td>Verified AppArmor/SELinux active</td>
            <td>Enforce application-level security</td>
          </tr>
          <tr>
            <td><strong>Automatic Updates</strong></td>
            <td>Enabled unattended-upgrades</td>
            <td>Maintain up-to-date security patches</td>
          </tr>
          <tr>
            <td><strong>User Priviledge Management</strong></td>
            <td>Created limited user, removed default admin</td>
            <td>Principle of least privilege</td>
          </tr>
          <tr>
            <td><strong>Network Security</strong></td>
            <td>Checked open ports</td>
            <td>Identify unnecessary exposed services</td>
          </tr>
        </tbody>
      </table>
      <h3>Threat Model</h3>
      <p>The threat model outlines three seperate security concerns and suggests mitigation strategies for each of them.</p>
      <ul>
        <li>
          <strong>Brute-force SSH attacks:</strong> This occurs when an attacker repeatedly attempts to guess login credentials to gain remote access. 
          To prevent this, I will disable root login, reduced the number of allowed authentication attempts, and configured the firewall to restrict 
          repeated SSH connections, significantly lowering the chance of unauthorised access.
        </li>
        <br>
        <li>
          <strong>Privilege escalation:</strong> This threat involves a regular user gaining administrative access, often through misconfigured permissions 
          or exploitation of vulnerabilities. I will mitigate this by enforcing the principle of least privilege, creating dedicated non-root user accounts, 
          and carefully controlling <code>sudo</code> access to minimise the risk of elevated privilege misuse.
        </li>
        <br>
        <li>
          <strong>Unpatched software vulnerabilities:</strong> Outdated packages can be exploited by attackers to compromise system security. 
          To address this, I will enable automatic updates using <code>unattended-upgrades</code> and scheduled periodic manual patch reviews to ensure 
          that the system remains fully updated with the latest security fixes.
        </li>
      </ul>
    </section>
    <section>
      <h2>Week 3: Application Selection for Performance Testing</h2>
      <h4>14/11/2025</h4>
      <h3>Application Selection Matrix</h3>
      <p>For performance evaluation, I selected a variety of applications that each represent a different
      type of workload. These applications allow me to test CPU, memory, network load and disk I/O to understand how the system performs under different stress conditions.</p>
      <table>
        <thead>
          <tr>
            <th>Application</th>
            <th>Workload Type</th>
            <th>Justification</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>stress-ng --cpu 2</code></td>
            <td>CPU-intensive</td>
            <td>Generates sustained CPU load, good for analysing processor performance.</td>
          </tr>
          <tr>
            <td><code>stress-ng --vm 1 --vm-bytes 512M</code></td>
            <td>RAM-intensive</td>
            <td>Allows controlled memory allocation to test RAM pressure and swapping.</td>
          </tr>
          <tr>
            <td><code>iperf3</code></td>
            <td>Network-intensive</td>
            <td>Measures network throughput and latency under controlled conditions.</td>
          </tr>
          <tr>
            <td><code>dd if=/dev/zero of=testfile bs=1M count=500</code></td>
            <td>I/O-intensive</td>
            <td>Creates a large file to simulate heavy disk write operations.</td>
          </tr>
        </tbody>
      </table>
      <h3>Installation Documentation</h3>
      <p></p>All applications were installed remotely over SSH to maintain a headless, command-line focused
      administration environment. The following commands were executed after connecting to the server via:
      <code>ssh -p 2222 admin@127.0.0.1</code>.</p>
      <pre>Update any repositories <code>sudo apt install</code></pre>
      <pre>Install network testing tools <code>sudo apt install -y iperf3</code></pre>
      <pre>Intsall stress testing tools <code>sudo apt install -y stress-ng</code></pre>
      <pre>Install I/O performance analyser <code>sudo apt intall -y fio</code></pre>
      <h3>Resource Profiles and Usage</h3>
      <ul>
        <li><strong>CPU-intensive:</strong> The <code>stress-ng --cpu 2</code> test is expected to cause
        near 100% CPU utilisation on the selected cores, with minimal RAM, disk, or network usage.</li>
        <li><strong>RAM-intensive:</strong> The <code>stress-ng --vm 1 --vm-bytes 512M</code> test should significantly
        increase memory usage, potentially triggering swapping if RAM limits are reached, while CPU and
        disk activity remain moderate.</li>
        <li><strong>Network-intensive:</strong> Using <code>iperf3</code> should produce high network
        throughput and increased socket activity, while CPU, RAM, and disk remain lightly used.</li>
        <li><strong>I/O-intensive:</strong> The <code>dd if=/dev/zero of=testfile bs=1M count=500</code> file creation test is expected to generate
        high disk write throughput and moderate CPU usage, with minimal RAM and no network activity.</li>
      </ul>
      <h3>Monitoring Strategy</h3>
      <p>To measure system performance during each workload, I created a monitoring strategy using a range of 
      command-line tools that provide real-time system metrics. CPU and memory usage will be observed using 
      <code>top</code> and <code>vmstat</code>, which allow me to track load averages, process activity, and 
      overall memory utilisation. Disk performance will be monitored using <code>iostat</code> and <code>df -h</code> 
      to measure throughput and file system usage, while network-intensive workloads will be analysed using 
      <code>ss -tuln</code> and <code>ping</code> to monitor socket activity and latency. Logs will be collected using 
      <code>journalctl</code> to identify any unusual behaviour or performance issues. Each workload will be measured 
      before, during, and after execution to compare performance changes across different scenarios and identify 
      any potential bottlenecks.</p>
    </section>
    <section>
      <h2>Week 4: Initial System Configuration & Security Implementation</h2>
      <h4>21/11/25</h4>
      <p>I focused on securing my Linux server while managing it entirely through SSH. I implemented key-based authentication,
        configured a restrictive firewall, created a non-root administrative user, and documented all changes.
        This phase strengthened the server’s security and ensured that all administration was performed remotely and securely.</p>
      <h3>Configure SSH</h3>
      <p>In this section, I configured the server to use key-based SSH authentication instead of passwords. I generated 
        a secure key pair, added my public key to the server, and disabled password authentication in the SSH configuration. 
        This significantly improved the security of remote access by preventing brute-force login attempts.</p>
      <img src="PhaseFourSection1.png" alt="Configure SSH" align="middle" class="fixed-img">
      <img src="PhaseFourSection1Config.png" alt="Configure SSH Config" align="middle" class="fixed-img">
      <h3>Configure Firewall</h3>
      <p>Here, I implemented a strict firewall policy to ensure that SSH access is only permitted from my workstation. 
        By allowing a single source IP, I reduced the server’s attack surface and ensured that no other device can attempt an SSH connection.
        This follows the principle of least privilege.</p>
      <img src="PhaseFourSection2.png" alt="Configure Firewall" align="middle" class="fixed-img">
      <h3>Manage Users</h3>
      <p>In this section, I created a dedicated non-root administrative user and granted them the necessary sudo privileges. 
        This allowed me to disable direct root login while still being able to perform administrative tasks when required. 
        This step improved accountability and aligned the system with Linux security best practices.</p>
      <img src="PhaseFourSection3.png" alt="Manage Users" align="middle" class="fixed-img">
      <h3>SSH Access Evidence</h3>
      <p>Here, I collected screenshots showing that I could successfully connect to the server via SSH after applying the security changes.
        These screenshots provide proof that key-based authentication works and that I can administer the system without relying on insecure methods.</p>
      <img src="PhaseFourSection4.png" alt="SSH Access Evidence" align="middle" class="fixed-img">
      <h3>Configuration Files</h3>
      <p>In this section, I documented the changes I made to important configuration files, such as <code>sshd_config</code>. I included “before and after” comparisons
        to clearly show how I modified system settings and explain why each change was necessary for security.</p>
      <p>Before:</p>
      <img src="PhaseFourSection5Before.png" alt="Configuration Files Before" align="middle" class="fixed-img">
      <p>After:</p>
      <img src="PhaseFourSection5After.png" alt="Configuration Files After" align="middle" class="fixed-img">
      <h3>Firewall Documentation</h3>
      <p>For this part, I captured the full firewall ruleset using commands such as ufw status numbered. I explained what each rule does and how it contributes to securing the server.
        This documentation provides a clear overview of the system’s network-level protections.</p>
      <img src="PhaseFourSection6.png" alt="Firewall Documentation" align="middle" class="fixed-img">
      <h3>Remote Administration Evidence demonstrating commands executed via SSH</h3>
      <p>In the final section, I demonstrated that all system changes were carried out remotely via SSH, in line with the module’s requirements. 
        I gathered evidence of administrative commands being executed from my workstation to show that I managed the server headlessly without relying on the VirtualBox console.</p>
      <p>I had to update both UFW and my SSH key configuration because the VM was blocking legitimate SSH traffic and rejecting my authentication. VirtualBox NAT forwards connections
        from the host as coming from <code>10.0.2.2</code>, not <code>127.0.0.1</code>, so UFW was silently dropping the packets until I added a rule allowing SSH from the NAT gateway. At the same time, 
        password authentication had been disabled for security, but the VM did not yet contain the correct public key from my Mac. This caused SSH to reject every login attempt until
        I added my key to authorized_keys and configured my Mac to use the correct private key.</p>
      <img src="PhaseFourSection7Config.png" alt="SSH Evidence Config File" align="middle" class="fixed-img">
      <img src="PhaseFourSection7UFW.png" alt="SSH Evidence Firewall" align="middle" class="fixed-img">
      <img src="PhaseFourSection7Update.png" alt="SSH Evidence Update" align="middle" class="fixed-img">
      <img src="PhaseFourSection7Exit.png" alt="SSH Evidence Exit" align="middle" class="fixed-img">
    </section>
    <section>
      <h2>Week 5: Advanced Security and Monitoring Infrastructure</h2>
      <h4>28/11/2025</h4>
      <h3>Implementing Access Control Using AppArmor</h3>
      <p>To strengthen the server’s security posture, I enabled mandatory access control using AppArmor, which restricts program behaviour through profile-based rule enforcement. 
        This adds an additional layer of defence beyond standard UNIX permissions, ensuring that even if an application is compromised, its actions remain tightly controlled by its assigned security profile. 
        I installed the necessary AppArmor tools using <code>sudo apt update</code> and <code>sudo apt install -y apparmor apparmor-utils</code>, then ensured the service was active with <code>sudo systemctl enable --now apparmor</code>. 
        To generate evidence for my journal and confirm that AppArmor was correctly enforcing policies, I used <code>sudo aa-status</code> to list all active profiles and their modes. 
        This provides a clear demonstration of how access control is applied at the system level and how profile enforcement can be monitored and reported as part of continuous security management.</p>
      <h3>Configuring Automatic Security Updates</h3>
      <p>To ensure the server stays protected against newly discovered vulnerabilities, I configured automated security updates using the unattended-upgrades package.
        Automated patching is essential for reducing the window of exposure caused by delayed manual updates, especially on headless or remotely administered systems.
        I installed the update automation tools with <code>sudo apt install -y unattended-upgrades apt-listchanges</code> and enabled them using <code>sudo dpkg-reconfigure --priority=low unattended-upgrades</code>, 
        which configures the system to automatically apply security patches. I verified that the service was functioning properly with <code>sudo systemctl enable --now unattended-upgrades</code> and <code>sudo systemctl status unattended-upgrades</code>, 
        then collected evidence of recent patch activity using <code>sudo journalctl -u unattended-upgrades --no-pager | tail -n 50</code>. These commands demonstrate that the system is consistently receiving security patches without manual intervention,
        strengthening long-term system resilience.</p>
      <h3>Configure fail2ban</h3>
      <p>To protect the server against brute-force attacks, I deployed and configured fail2ban, which automatically monitors authentication logs and bans IP addresses that repeatedly fail login attempts. This significantly reduces the attack surface for 
        SSH and protects against automated intrusion attempts, which are common across public networks. I began by installing fail2ban with <code>sudo apt install -y fail2ban</code>, then created a local jail configuration using 
        <pre><code style="border: 0px">
          sudo bash -c 'cat > /etc/fail2ban/jail.d/ssh.local EOF
          [sshd]
          enabled = true
          port = 22
          filter = sshd
          logpath = /var/log/auth.log
          maxretry = 3
          bantime = 3600
          EOF'</code></pre>
        to enable SSH protection, set a maximum of three failed attempts, and apply a one-hour ban time. I activated the service with <code>sudo systemctl restart fail2ban</code> and verified its operation using both <code>sudo fail2ban-client status</code> 
        and <code>sudo fail2ban-client status sshd</code>. These commands confirm that fail2ban is actively monitoring <code>/var/log/auth.log</code> and automatically enforcing bans, providing a strong intrusion detection and mitigation mechanism for the server.</p>
      <h3>Security Baseline Verification Script</h3>
      <p>The <code>security-baseline.sh</code> script runs on the server and automatically checks that all security controls from weeks 4 and 5 are correctly configured. It verifies AppArmor, automatic updates, fail2ban, SSH hardening, firewall rules, and authorised keys. 
        This script is needed because it provides a quick, repeatable way to confirm that the system’s security posture is stable and has not drifted from the intended configuration.</p>
      <pre><code style="border: 0px">
        #!/bin/bash
        # security-baseline.sh
        # Purpose: verify the server's security configuration (Phase 4 & 5). Run as root or with sudo.
        # Usage: sudo ./security-baseline.sh
        
        set -euo pipefail
        
        # Helper: print section header
        header() {
          echo
          echo "==================== $1 ===================="
        }
        
        header "Date / Host"
        date
        hostnamectl
        
        header "1) AppArmor status"
        if command -v aa-status >/dev/null 2>&1; then
          aa-status || apparmor_status || true
        else
          echo "AppArmor tools not installed."
        fi
        
        header "2) Unattended upgrades"
        if systemctl is-active --quiet unattended-upgrades 2>/dev/null; then
          echo "unattended-upgrades: active"
          sudo journalctl -u unattended-upgrades --no-pager | tail -n 10
        else
          echo "unattended-upgrades: NOT active"
        fi
        
        header "3) fail2ban"
        if command -v fail2ban-client >/dev/null 2>&1; then
          sudo fail2ban-client status || true
          echo "SSH jail status:"
          sudo fail2ban-client status sshd || echo "sshd jail not configured"
        else
          echo "fail2ban not installed."
        fi
        
        header "4) SSH hardening checks"
        SSHD_CONFIG="/etc/ssh/sshd_config"
        echo "Checking $SSHD_CONFIG for common hardening settings..."
        sudo grep -E "^(PermitRootLogin|PasswordAuthentication|PubkeyAuthentication|PermitEmptyPasswords|ChallengeResponseAuthentication)" "$SSHD_CONFIG" || true
        
        # Check that password authentication is disabled
        if sudo grep -qE "^PasswordAuthentication\s+no" "$SSHD_CONFIG" ; then
          echo "PasswordAuthentication disabled (OK)"
        else
          echo "Warning: PasswordAuthentication not set to 'no'"
        fi
        
        # Check root login disabled
        if sudo grep -qE "^PermitRootLogin\s+no" "$SSHD_CONFIG" ; then
          echo "PermitRootLogin disabled (OK)"
        else
          echo "Warning: PermitRootLogin not set to 'no'"
        fi
        
        header "5) UFW rules (firewall)"
        if command -v ufw >/dev/null 2>&1; then
          sudo ufw status verbose
        else
          echo "UFW not installed."
        fi
        
        header "6) Authorized keys for 'admin' user"
        ADMIN_HOME=$(getent passwd admin | cut -d: -f6 2>/dev/null || echo "/home/admin")
        if [ -f "$ADMIN_HOME/.ssh/authorized_keys" ]; then
          echo "authorized_keys exists:"
          sudo ls -l "$ADMIN_HOME/.ssh/authorized_keys"
          sudo tail -n 5 "$ADMIN_HOME/.ssh/authorized_keys"
        else
          echo "No authorized_keys file for admin"
        fi
        
        header "7) Basic resource snapshot"
        echo "Memory:"
        free -h
        echo "Disk:"
        df -h /
        echo "Uptime and load:"
        uptime
        
        echo
        echo "Security baseline verification complete."
      </code></pre>
      <img src="VerificationScript1.png" alt="Verification Script 1" align="middle" class="fixed-img">
      <img src="VerificationScript2.png" alt="Verification Script 2" align="middle" class="fixed-img">
      <img src="VerificationScript3.png" alt="Verification Script 3" align="middle" class="fixed-img">
      <img src="VerificationScript4.png" alt="Verification Script 4" align="middle" class="fixed-img">
      <img src="VerificationScript5.png" alt="Verification Script 5" align="middle" class="fixed-img">
      <h3>Remote Monitoring Script</h3>
      <p>The <code>monitor-server.sh</code> script runs from my workstation and connects to the server via SSH to collect live performance and security metrics. It captures information such as memory usage,
        disk space, active processes, and recent authentication logs, saving everything into a timestamped report. This script is important because it allows remote health monitoring without direct server access,
        demonstrating automated administration and early issue detection.</p>
      <pre><code style="border: 0px">
        #!/bin/bash
        # monitor-server.sh
        # Connect to server via SSH and collect performance metrics for remote monitoring.
        # ./monitor-server.sh admin@127.0.0.1 -p 2222
        
        set -euo pipefail
        
        # Parse args (simple)
        REMOTE="${1:-admin@127.0.0.1}"
        SSH_OPTS="-p 2222 -o BatchMode=yes -o StrictHostKeyChecking=accept-new"
        OUTDIR="./monitor-output"
        mkdir -p "$OUTDIR"
        TIMESTAMP=$(date -u +"%Y%m%dT%H%M%SZ")
        OUTFILE="$OUTDIR/metrics-$TIMESTAMP.txt"
        
        echo "Collecting metrics from $REMOTE at $TIMESTAMP"
        {
          echo "==== Host info ===="
          ssh $SSH_OPTS "$REMOTE" 'hostnamectl; uname -a'
        
          echo
          echo "==== Memory ===="
          ssh $SSH_OPTS "$REMOTE" 'free -h'
        
          echo
          echo "==== Disk ===="
          ssh $SSH_OPTS "$REMOTE" 'df -h'
        
          echo
          echo "==== Top processes (snapshot) ===="
          ssh $SSH_OPTS "$REMOTE" 'ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu | head -n 15'
        
          echo
          echo "==== Network connections ===="
          ssh $SSH_OPTS "$REMOTE" 'ss -tuln | head -n 20'
        
          echo
          echo "==== Recent auth logs (last 100 lines) ===="
          ssh $SSH_OPTS "$REMOTE" 'sudo tail -n 100 /var/log/auth.log || sudo journalctl -u ssh -n 100 --no-pager'
        
          echo
          echo "==== Security baseline (quick) ===="
          ssh $SSH_OPTS "$REMOTE" 'sudo /usr/local/bin/security-baseline.sh || echo "security-baseline.sh not present"'
        
        } > "$OUTFILE"
        
        echo "Saved metrics to $OUTFILE"
      </code></pre>
    </section>
    <section>
      <h2>Week 6: Performance Evaluation and Analysis</h1>
      <h4>5/12/2025</h4>
      <h3>Documentation of Approach</h3>
      <p>I conducted performance tests using selected workloads to measure CPU, memory, disk I/O, network throughput, and latency.
        Baseline measurements were collected with monitoring tools (vmstat, free, iostat, ping). Stress tests were executed using stress-ng,
        iperf3, and dd, with outputs captured for comparison. After identifying bottlenecks, I applied two optimisations (noatime and reduced swappiness),
        re-ran tests, and recorded improvements. Data was organised into structured tables and visualised with charts for clear analysis</p>
      <h3>Performance Data Table</h3>
      <table>
        <thead>
          <tr>
            <th>Workload</th>
            <th>Test Type</th>
            <th>CPU Usage</th>
            <th>Memory Usage</th>
            <th>Disk I/O</th>
            <th>Network</th>
            <th>Latency</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Baseline</td>
            <td>Idle System</td>
            <td>9% (top)</td>
            <td>284 MB used / 1065 MB free</td>
            <td>–</td>
            <td>–</td>
            <td>–</td>
          </tr>
      
          <tr>
            <td>CPU-Intensive</td>
            <td><code>stress-ng --cpu 2</code></td>
            <td>~198% across 2 vCPUs</td>
            <td>290 MB used</td>
            <td>–</td>
            <td>–</td>
            <td>–</td>
          </tr>
      
          <tr>
            <td>RAM-Intensive</td>
            <td><code>stress-ng --vm 1 --vm-bytes 512M</code></td>
            <td>~15%</td>
            <td>400 MB used / 950 MB free</td>
            <td>–</td>
            <td>–</td>
            <td>–</td>
          </tr>
      
          <tr>
            <td>Disk I/O</td>
            <td><code>dd if=/dev/zero of=testfile</code></td>
            <td>~35% (top)</td>
            <td>300 MB used</td>
            <td>2.3 GB/s write throughput</td>
            <td>–</td>
            <td>–</td>
          </tr>
      
          <tr>
            <td>Network Throughput</td>
            <td><code>iperf3 -c 10.0.2.2</code></td>
            <td>18% (top)</td>
            <td>–</td>
            <td>–</td>
            <td>620 Mbps (2 retransmits)</td>
            <td>avg 0.355 ms</td>
          </tr>
        </tbody>
      </table>
      <h3>Performance Visualisations</h3>
      <img src="cpu-usage.png" alt="CPU Usage" align="middle" class="fixed-img">
      <img src="ram-usage.png" alt="Ram Usage" align="middle" class="fixed-img">
      <img src="disk-io.png" alt="Disk I/O" align="middle" class="fixed-img">
      <img src="network.png" alt="Network" align="middle" class="fixed-img">
      <h3>Testing Evidence</h3>
      <img src="Week6TestData1.png" alt="Test Data 1" align="middle" class="fixed-img">
      <img src="Week6TestData2.png" alt="Test Data 2" align="middle" class="fixed-img">
      <h3>Network Performance Analysis</h3>
      <h3>Optimisation Analysis</h3>
    </section>
  </main>

  <footer>
    © 2025 Jack Turner | Operating Systems Module
  </footer>
</body>
</html>
